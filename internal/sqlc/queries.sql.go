// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
)

const booksStat = `-- name: BooksStat :one



select count(*) as book_count, count(distinct id) as unique_book_count, max(id) as max_book_id from books where site=$1
`

type BooksStatRow struct {
	BookCount       int64
	UniqueBookCount int64
	MaxBookID       interface{}
}

// -- name: BackupBooks :exec
// copy (select * from books where site=$1) to '$2'
// csv header quote as ”” force quote *;
// -- name: BackupWriters :exec
// copy (
//
//	select distinct(writers.*) from writers join books on writers.id=books.writer_id
//	where books.site=$1
//
// ) to '$2' csv header quote as ”” force quote *;
// -- name: BackupError :exec
// copy (select * from errors where site=$1) to '$2'
// csv header quote as ”” force quote *;
func (q *Queries) BooksStat(ctx context.Context, site string) (BooksStatRow, error) {
	row := q.db.QueryRowContext(ctx, booksStat, site)
	var i BooksStatRow
	err := row.Scan(&i.BookCount, &i.UniqueBookCount, &i.MaxBookID)
	return i, err
}

const booksStatusStat = `-- name: BooksStatusStat :many
select status, count(*) from books where site=$1 group by status
`

type BooksStatusStatRow struct {
	Status string
	Count  int64
}

func (q *Queries) BooksStatusStat(ctx context.Context, site string) ([]BooksStatusStatRow, error) {
	rows, err := q.db.QueryContext(ctx, booksStatusStat, site)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BooksStatusStatRow
	for rows.Next() {
		var i BooksStatusStatRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createBookWithHash = `-- name: CreateBookWithHash :one
INSERT INTO books
(site, id, hash_code, title, writer_id, writer_checksum, type, 
update_date, update_chapter, status, is_downloaded, checksum)
VALUES
($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING site, id, hash_code, title, writer_id, type, update_date, update_chapter, status, is_downloaded, checksum, writer_checksum
`

type CreateBookWithHashParams struct {
	Site           string
	ID             int32
	HashCode       int32
	Title          sql.NullString
	WriterID       sql.NullInt32
	WriterChecksum sql.NullString
	Type           sql.NullString
	UpdateDate     sql.NullString
	UpdateChapter  sql.NullString
	Status         string
	IsDownloaded   bool
	Checksum       sql.NullString
}

func (q *Queries) CreateBookWithHash(ctx context.Context, arg CreateBookWithHashParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, createBookWithHash,
		arg.Site,
		arg.ID,
		arg.HashCode,
		arg.Title,
		arg.WriterID,
		arg.WriterChecksum,
		arg.Type,
		arg.UpdateDate,
		arg.UpdateChapter,
		arg.Status,
		arg.IsDownloaded,
		arg.Checksum,
	)
	var i Book
	err := row.Scan(
		&i.Site,
		&i.ID,
		&i.HashCode,
		&i.Title,
		&i.WriterID,
		&i.Type,
		&i.UpdateDate,
		&i.UpdateChapter,
		&i.Status,
		&i.IsDownloaded,
		&i.Checksum,
		&i.WriterChecksum,
	)
	return i, err
}

const createBookWithZeroHash = `-- name: CreateBookWithZeroHash :one
INSERT INTO books
(site, id, hash_code, title, writer_id, writer_checksum, type, 
update_date, update_chapter, status, is_downloaded, checksum)
VALUES
($1, $2, 0, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING site, id, hash_code, title, writer_id, type, update_date, update_chapter, status, is_downloaded, checksum, writer_checksum
`

type CreateBookWithZeroHashParams struct {
	Site           string
	ID             int32
	Title          sql.NullString
	WriterID       sql.NullInt32
	WriterChecksum sql.NullString
	Type           sql.NullString
	UpdateDate     sql.NullString
	UpdateChapter  sql.NullString
	Status         string
	IsDownloaded   bool
	Checksum       sql.NullString
}

func (q *Queries) CreateBookWithZeroHash(ctx context.Context, arg CreateBookWithZeroHashParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, createBookWithZeroHash,
		arg.Site,
		arg.ID,
		arg.Title,
		arg.WriterID,
		arg.WriterChecksum,
		arg.Type,
		arg.UpdateDate,
		arg.UpdateChapter,
		arg.Status,
		arg.IsDownloaded,
		arg.Checksum,
	)
	var i Book
	err := row.Scan(
		&i.Site,
		&i.ID,
		&i.HashCode,
		&i.Title,
		&i.WriterID,
		&i.Type,
		&i.UpdateDate,
		&i.UpdateChapter,
		&i.Status,
		&i.IsDownloaded,
		&i.Checksum,
		&i.WriterChecksum,
	)
	return i, err
}

const createError = `-- name: CreateError :one
insert into errors (site, id, data) values ($1, $2, $3)
on conflict (site, id)
do update set data=$3
RETURNING site, id, data
`

type CreateErrorParams struct {
	Site sql.NullString
	ID   sql.NullInt32
	Data sql.NullString
}

func (q *Queries) CreateError(ctx context.Context, arg CreateErrorParams) (Error, error) {
	row := q.db.QueryRowContext(ctx, createError, arg.Site, arg.ID, arg.Data)
	var i Error
	err := row.Scan(&i.Site, &i.ID, &i.Data)
	return i, err
}

const createWriter = `-- name: CreateWriter :one
insert into writers (name, checksum) values ($1, $2) 
on conflict (name) do update set name=$1 
returning id, name, checksum
`

type CreateWriterParams struct {
	Name     sql.NullString
	Checksum sql.NullString
}

func (q *Queries) CreateWriter(ctx context.Context, arg CreateWriterParams) (Writer, error) {
	row := q.db.QueryRowContext(ctx, createWriter, arg.Name, arg.Checksum)
	var i Writer
	err := row.Scan(&i.ID, &i.Name, &i.Checksum)
	return i, err
}

const deleteError = `-- name: DeleteError :one
delete from errors where site=$1 and id=$2 returning site, id, data
`

type DeleteErrorParams struct {
	Site sql.NullString
	ID   sql.NullInt32
}

func (q *Queries) DeleteError(ctx context.Context, arg DeleteErrorParams) (Error, error) {
	row := q.db.QueryRowContext(ctx, deleteError, arg.Site, arg.ID)
	var i Error
	err := row.Scan(&i.Site, &i.ID, &i.Data)
	return i, err
}

const downloadedBooksStat = `-- name: DownloadedBooksStat :one
select count(*) as downloaded_count from books where site=$1 and is_downloaded=true
`

func (q *Queries) DownloadedBooksStat(ctx context.Context, site string) (int64, error) {
	row := q.db.QueryRowContext(ctx, downloadedBooksStat, site)
	var downloaded_count int64
	err := row.Scan(&downloaded_count)
	return downloaded_count, err
}

const errorBooksStat = `-- name: ErrorBooksStat :one
select count(*) as error_count from books where site=$1 and status='ERROR'
`

func (q *Queries) ErrorBooksStat(ctx context.Context, site string) (int64, error) {
	row := q.db.QueryRowContext(ctx, errorBooksStat, site)
	var error_count int64
	err := row.Scan(&error_count)
	return error_count, err
}

const findAllBookIDs = `-- name: FindAllBookIDs :many
select distinct(id) as book_id from books where site=$1 order by book_id
`

func (q *Queries) FindAllBookIDs(ctx context.Context, site string) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, findAllBookIDs, site)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var book_id int32
		if err := rows.Scan(&book_id); err != nil {
			return nil, err
		}
		items = append(items, book_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookByID = `-- name: GetBookByID :one
select books.site, books.id, books.hash_code, books.title,
  books.writer_id, coalesce(writers.name, ''), books.type,
  books.update_date, books.update_chapter, 
  books.status, books.is_downloaded, coalesce(errors.data, '')
from books left join writers on books.writer_id=writers.id 
  left join errors on books.site=errors.site and books.id=errors.id
where books.site=$1 and books.id=$2 order by books.hash_code desc
`

type GetBookByIDParams struct {
	Site string
	ID   int32
}

type GetBookByIDRow struct {
	Site          string
	ID            int32
	HashCode      int32
	Title         sql.NullString
	WriterID      sql.NullInt32
	Name          string
	Type          sql.NullString
	UpdateDate    sql.NullString
	UpdateChapter sql.NullString
	Status        string
	IsDownloaded  bool
	Data          string
}

func (q *Queries) GetBookByID(ctx context.Context, arg GetBookByIDParams) (GetBookByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getBookByID, arg.Site, arg.ID)
	var i GetBookByIDRow
	err := row.Scan(
		&i.Site,
		&i.ID,
		&i.HashCode,
		&i.Title,
		&i.WriterID,
		&i.Name,
		&i.Type,
		&i.UpdateDate,
		&i.UpdateChapter,
		&i.Status,
		&i.IsDownloaded,
		&i.Data,
	)
	return i, err
}

const getBookByIDHash = `-- name: GetBookByIDHash :one
select books.site, books.id, books.hash_code, books.title,
  books.writer_id, coalesce(writers.name, ''), books.type,
  books.update_date, books.update_chapter, 
  books.status, books.is_downloaded, coalesce(errors.data, '')
from books left join writers on books.writer_id=writers.id 
  left join errors on books.site=errors.site and books.id=errors.id
where books.site=$1 and books.id=$2 and books.hash_code=$3
order by hash_code desc
`

type GetBookByIDHashParams struct {
	Site     string
	ID       int32
	HashCode int32
}

type GetBookByIDHashRow struct {
	Site          string
	ID            int32
	HashCode      int32
	Title         sql.NullString
	WriterID      sql.NullInt32
	Name          string
	Type          sql.NullString
	UpdateDate    sql.NullString
	UpdateChapter sql.NullString
	Status        string
	IsDownloaded  bool
	Data          string
}

func (q *Queries) GetBookByIDHash(ctx context.Context, arg GetBookByIDHashParams) (GetBookByIDHashRow, error) {
	row := q.db.QueryRowContext(ctx, getBookByIDHash, arg.Site, arg.ID, arg.HashCode)
	var i GetBookByIDHashRow
	err := row.Scan(
		&i.Site,
		&i.ID,
		&i.HashCode,
		&i.Title,
		&i.WriterID,
		&i.Name,
		&i.Type,
		&i.UpdateDate,
		&i.UpdateChapter,
		&i.Status,
		&i.IsDownloaded,
		&i.Data,
	)
	return i, err
}

const getBookGroupByID = `-- name: GetBookGroupByID :many
select books.site, books.id, books.hash_code, books.title,
  books.writer_id, coalesce(writers.name, ''), books.type,
  books.update_date, books.update_chapter, 
  books.status, books.is_downloaded, coalesce(errors.data, '')
from books
  left join writers on books.writer_id=writers.id 
  left join errors on books.site=errors.site and books.id=errors.id
where (books.checksum, books.writer_checksum) = (
  select bks.checksum, bks.writer_checksum from books as bks 
  where bks.site=$1 and bks.id=$2 
  and bks.checksum != '' and bks.writer_checksum != ''
  order by bks.hash_code desc limit 1
) or books.site=$1 and books.id=$2
`

type GetBookGroupByIDParams struct {
	Site string
	ID   int32
}

type GetBookGroupByIDRow struct {
	Site          string
	ID            int32
	HashCode      int32
	Title         sql.NullString
	WriterID      sql.NullInt32
	Name          string
	Type          sql.NullString
	UpdateDate    sql.NullString
	UpdateChapter sql.NullString
	Status        string
	IsDownloaded  bool
	Data          string
}

func (q *Queries) GetBookGroupByID(ctx context.Context, arg GetBookGroupByIDParams) ([]GetBookGroupByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getBookGroupByID, arg.Site, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookGroupByIDRow
	for rows.Next() {
		var i GetBookGroupByIDRow
		if err := rows.Scan(
			&i.Site,
			&i.ID,
			&i.HashCode,
			&i.Title,
			&i.WriterID,
			&i.Name,
			&i.Type,
			&i.UpdateDate,
			&i.UpdateChapter,
			&i.Status,
			&i.IsDownloaded,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookGroupByIDHash = `-- name: GetBookGroupByIDHash :many
select books.site, books.id, books.hash_code, books.title,
  books.writer_id, coalesce(writers.name, ''), books.type,
  books.update_date, books.update_chapter, 
  books.status, books.is_downloaded, coalesce(errors.data, '')
from books
  left join writers on books.writer_id=writers.id 
  left join errors on books.site=errors.site and books.id=errors.id
where (books.checksum, books.writer_checksum) = (
  select bks.checksum, bks.writer_checksum from books as bks 
  where bks.site=$1 and bks.id=$2 and bks.hash_code=$3 
  and bks.checksum != '' and bks.writer_checksum != ''
  order by bks.hash_code desc limit 1
) or books.site=$1 and books.id=$2
`

type GetBookGroupByIDHashParams struct {
	Site     string
	ID       int32
	HashCode int32
}

type GetBookGroupByIDHashRow struct {
	Site          string
	ID            int32
	HashCode      int32
	Title         sql.NullString
	WriterID      sql.NullInt32
	Name          string
	Type          sql.NullString
	UpdateDate    sql.NullString
	UpdateChapter sql.NullString
	Status        string
	IsDownloaded  bool
	Data          string
}

func (q *Queries) GetBookGroupByIDHash(ctx context.Context, arg GetBookGroupByIDHashParams) ([]GetBookGroupByIDHashRow, error) {
	rows, err := q.db.QueryContext(ctx, getBookGroupByIDHash, arg.Site, arg.ID, arg.HashCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookGroupByIDHashRow
	for rows.Next() {
		var i GetBookGroupByIDHashRow
		if err := rows.Scan(
			&i.Site,
			&i.ID,
			&i.HashCode,
			&i.Title,
			&i.WriterID,
			&i.Name,
			&i.Type,
			&i.UpdateDate,
			&i.UpdateChapter,
			&i.Status,
			&i.IsDownloaded,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooks = `-- name: ListBooks :many
select books.site, books.id, books.hash_code, books.title,
  books.writer_id, coalesce(writers.name, ''), books.type,
  books.update_date, books.update_chapter, 
  books.status, books.is_downloaded, coalesce(errors.data, '')
from books left join writers on books.writer_id=writers.id 
  left join errors on books.site=errors.site and books.id=errors.id
where books.site=$1
order by books.site, books.id, books.hash_code
`

type ListBooksRow struct {
	Site          string
	ID            int32
	HashCode      int32
	Title         sql.NullString
	WriterID      sql.NullInt32
	Name          string
	Type          sql.NullString
	UpdateDate    sql.NullString
	UpdateChapter sql.NullString
	Status        string
	IsDownloaded  bool
	Data          string
}

func (q *Queries) ListBooks(ctx context.Context, site string) ([]ListBooksRow, error) {
	rows, err := q.db.QueryContext(ctx, listBooks, site)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBooksRow
	for rows.Next() {
		var i ListBooksRow
		if err := rows.Scan(
			&i.Site,
			&i.ID,
			&i.HashCode,
			&i.Title,
			&i.WriterID,
			&i.Name,
			&i.Type,
			&i.UpdateDate,
			&i.UpdateChapter,
			&i.Status,
			&i.IsDownloaded,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooksByStatus = `-- name: ListBooksByStatus :many
select books.site, books.id, books.hash_code, books.title,
  books.writer_id, coalesce(writers.name, ''), books.type,
  books.update_date, books.update_chapter, 
  books.status, books.is_downloaded, coalesce(errors.data, '')
from books left join writers on books.writer_id=writers.id 
  left join errors on books.site=errors.site and books.id=errors.id
where books.site=$1 and books.status=$2 order by hash_code desc
`

type ListBooksByStatusParams struct {
	Site   string
	Status string
}

type ListBooksByStatusRow struct {
	Site          string
	ID            int32
	HashCode      int32
	Title         sql.NullString
	WriterID      sql.NullInt32
	Name          string
	Type          sql.NullString
	UpdateDate    sql.NullString
	UpdateChapter sql.NullString
	Status        string
	IsDownloaded  bool
	Data          string
}

func (q *Queries) ListBooksByStatus(ctx context.Context, arg ListBooksByStatusParams) ([]ListBooksByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listBooksByStatus, arg.Site, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBooksByStatusRow
	for rows.Next() {
		var i ListBooksByStatusRow
		if err := rows.Scan(
			&i.Site,
			&i.ID,
			&i.HashCode,
			&i.Title,
			&i.WriterID,
			&i.Name,
			&i.Type,
			&i.UpdateDate,
			&i.UpdateChapter,
			&i.Status,
			&i.IsDownloaded,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooksByTitleWriter = `-- name: ListBooksByTitleWriter :many
select books.site, books.id, books.hash_code, books.title,
  books.writer_id, coalesce(writers.name, ''), books.type,
  books.update_date, books.update_chapter, 
  books.status, books.is_downloaded, coalesce(errors.data, '')
from books left join writers on books.writer_id=writers.id
  left join errors on books.site=errors.site and books.id=errors.id
where books.site=$1 and books.status != 'ERROR' and 
  (($2 != '%%' and books.title like $2) or
  ($3 != '%%' and writers.name like $3))
order by books.update_date desc, books.id desc limit $4 offset $5
`

type ListBooksByTitleWriterParams struct {
	Site    string
	Column2 interface{}
	Column3 interface{}
	Limit   int32
	Offset  int32
}

type ListBooksByTitleWriterRow struct {
	Site          string
	ID            int32
	HashCode      int32
	Title         sql.NullString
	WriterID      sql.NullInt32
	Name          string
	Type          sql.NullString
	UpdateDate    sql.NullString
	UpdateChapter sql.NullString
	Status        string
	IsDownloaded  bool
	Data          string
}

func (q *Queries) ListBooksByTitleWriter(ctx context.Context, arg ListBooksByTitleWriterParams) ([]ListBooksByTitleWriterRow, error) {
	rows, err := q.db.QueryContext(ctx, listBooksByTitleWriter,
		arg.Site,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBooksByTitleWriterRow
	for rows.Next() {
		var i ListBooksByTitleWriterRow
		if err := rows.Scan(
			&i.Site,
			&i.ID,
			&i.HashCode,
			&i.Title,
			&i.WriterID,
			&i.Name,
			&i.Type,
			&i.UpdateDate,
			&i.UpdateChapter,
			&i.Status,
			&i.IsDownloaded,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooksForDownload = `-- name: ListBooksForDownload :many
select distinct on (books.site, books.id) 
  books.site, books.id, books.hash_code, books.title,
  books.writer_id, coalesce(writers.name, ''), books.type,
  books.update_date, books.update_chapter, 
  books.status, books.is_downloaded, coalesce(errors.data, '')
from books left join writers on books.writer_id=writers.id 
  left join errors on books.site=errors.site and books.id=errors.id
where books.site=$1 and books.status='END' and books.is_downloaded=false
order by books.site, books.id desc, books.hash_code desc
`

type ListBooksForDownloadRow struct {
	Site          string
	ID            int32
	HashCode      int32
	Title         sql.NullString
	WriterID      sql.NullInt32
	Name          string
	Type          sql.NullString
	UpdateDate    sql.NullString
	UpdateChapter sql.NullString
	Status        string
	IsDownloaded  bool
	Data          string
}

func (q *Queries) ListBooksForDownload(ctx context.Context, site string) ([]ListBooksForDownloadRow, error) {
	rows, err := q.db.QueryContext(ctx, listBooksForDownload, site)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBooksForDownloadRow
	for rows.Next() {
		var i ListBooksForDownloadRow
		if err := rows.Scan(
			&i.Site,
			&i.ID,
			&i.HashCode,
			&i.Title,
			&i.WriterID,
			&i.Name,
			&i.Type,
			&i.UpdateDate,
			&i.UpdateChapter,
			&i.Status,
			&i.IsDownloaded,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooksForUpdate = `-- name: ListBooksForUpdate :many
select distinct on (books.site, books.id) 
  books.site, books.id, books.hash_code, books.title,
  books.writer_id, coalesce(writers.name, ''), books.type,
  books.update_date, books.update_chapter, 
  books.status, books.is_downloaded, coalesce(errors.data, '')
from books left join writers on books.writer_id=writers.id 
  left join errors on books.site=errors.site and books.id=errors.id
where books.site=$1
order by books.site, books.id desc, books.hash_code desc
`

type ListBooksForUpdateRow struct {
	Site          string
	ID            int32
	HashCode      int32
	Title         sql.NullString
	WriterID      sql.NullInt32
	Name          string
	Type          sql.NullString
	UpdateDate    sql.NullString
	UpdateChapter sql.NullString
	Status        string
	IsDownloaded  bool
	Data          string
}

func (q *Queries) ListBooksForUpdate(ctx context.Context, site string) ([]ListBooksForUpdateRow, error) {
	rows, err := q.db.QueryContext(ctx, listBooksForUpdate, site)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBooksForUpdateRow
	for rows.Next() {
		var i ListBooksForUpdateRow
		if err := rows.Scan(
			&i.Site,
			&i.ID,
			&i.HashCode,
			&i.Title,
			&i.WriterID,
			&i.Name,
			&i.Type,
			&i.UpdateDate,
			&i.UpdateChapter,
			&i.Status,
			&i.IsDownloaded,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRandomBooks = `-- name: ListRandomBooks :many
select books.site, books.id, books.hash_code, books.title,
  books.writer_id, coalesce(writers.name, ''), books.type,
  books.update_date, books.update_chapter, 
  books.status, books.is_downloaded, coalesce(errors.data, '')
from books left join writers on books.writer_id=writers.id 
  left join errors on books.site=errors.site and books.id=errors.id
where books.site=$1 and books.is_downloaded=true
order by books.site, books.id desc, books.hash_code desc 
limit $2 offset RANDOM() * 
(
  select greatest(count(*) - $2, 0)
  from books as bks where site=$1 and bks.is_downloaded=true
)
`

type ListRandomBooksParams struct {
	Site    string
	Column2 interface{}
}

type ListRandomBooksRow struct {
	Site          string
	ID            int32
	HashCode      int32
	Title         sql.NullString
	WriterID      sql.NullInt32
	Name          string
	Type          sql.NullString
	UpdateDate    sql.NullString
	UpdateChapter sql.NullString
	Status        string
	IsDownloaded  bool
	Data          string
}

func (q *Queries) ListRandomBooks(ctx context.Context, arg ListRandomBooksParams) ([]ListRandomBooksRow, error) {
	rows, err := q.db.QueryContext(ctx, listRandomBooks, arg.Site, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRandomBooksRow
	for rows.Next() {
		var i ListRandomBooksRow
		if err := rows.Scan(
			&i.Site,
			&i.ID,
			&i.HashCode,
			&i.Title,
			&i.WriterID,
			&i.Name,
			&i.Type,
			&i.UpdateDate,
			&i.UpdateChapter,
			&i.Status,
			&i.IsDownloaded,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nonErrorBooksStat = `-- name: NonErrorBooksStat :one
select max(id) as latest_success_id from books where status<>'ERROR' and site=$1
`

func (q *Queries) NonErrorBooksStat(ctx context.Context, site string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, nonErrorBooksStat, site)
	var latest_success_id interface{}
	err := row.Scan(&latest_success_id)
	return latest_success_id, err
}

const updateBook = `-- name: UpdateBook :one
Update books SET 
title=$4, writer_id=$5, writer_checksum=$12, type=$6, update_date=$7, update_chapter=$8,
status=$9, is_downloaded=$10, checksum=$11
WHERE site=$1 and id=$2 and hash_code=$3
RETURNING site, id, hash_code, title, writer_id, type, update_date, update_chapter, status, is_downloaded, checksum, writer_checksum
`

type UpdateBookParams struct {
	Site           string
	ID             int32
	HashCode       int32
	Title          sql.NullString
	WriterID       sql.NullInt32
	Type           sql.NullString
	UpdateDate     sql.NullString
	UpdateChapter  sql.NullString
	Status         string
	IsDownloaded   bool
	Checksum       sql.NullString
	WriterChecksum sql.NullString
}

func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, updateBook,
		arg.Site,
		arg.ID,
		arg.HashCode,
		arg.Title,
		arg.WriterID,
		arg.Type,
		arg.UpdateDate,
		arg.UpdateChapter,
		arg.Status,
		arg.IsDownloaded,
		arg.Checksum,
		arg.WriterChecksum,
	)
	var i Book
	err := row.Scan(
		&i.Site,
		&i.ID,
		&i.HashCode,
		&i.Title,
		&i.WriterID,
		&i.Type,
		&i.UpdateDate,
		&i.UpdateChapter,
		&i.Status,
		&i.IsDownloaded,
		&i.Checksum,
		&i.WriterChecksum,
	)
	return i, err
}

const updateBooksStatus = `-- name: UpdateBooksStatus :exec
update books set is_downloaded=false, status='END' 
where (update_date < $1 or 
    update_chapter like '%番外%' or update_chapter like '%結局%' or 
    update_chapter like '%新書%' or update_chapter like '%完結%' or 
    update_chapter like '%尾聲%' or update_chapter like '%感言%' or 
    update_chapter like '%後記%' or update_chapter like '%完本%' or 
    update_chapter like '%全書完%' or update_chapter like '%全文完%' or 
    update_chapter like '%全文終%' or update_chapter like '%全文結%' or 
    update_chapter like '%劇終%' or update_chapter like '%（完）%' or 
    update_chapter like '%終章%' or update_chapter like '%外傳%' or 
    update_chapter like '%結尾%' or update_chapter like '%番外%' or 
    update_chapter like '%结局%' or update_chapter like '%新书%' or 
    update_chapter like '%完结%' or update_chapter like '%尾声%' or 
    update_chapter like '%感言%' or update_chapter like '%后记%' or 
    update_chapter like '%完本%' or update_chapter like '%全书完%' or 
    update_chapter like '%全文完%' or update_chapter like '%全文终%' or 
    update_chapter like '%全文结%' or update_chapter like '%剧终%' or 
    update_chapter like '%（完）%' or update_chapter like '%终章%' or 
    update_chapter like '%外传%' or update_chapter like '%结尾%') and 
  status='INPROGRESS' and site=$2
`

type UpdateBooksStatusParams struct {
	UpdateDate sql.NullString
	Site       string
}

func (q *Queries) UpdateBooksStatus(ctx context.Context, arg UpdateBooksStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateBooksStatus, arg.UpdateDate, arg.Site)
	return err
}

const writersStat = `-- name: WritersStat :one
select count(distinct writers_id) as writer_count 
from books where site=$1
`

func (q *Queries) WritersStat(ctx context.Context, site string) (int64, error) {
	row := q.db.QueryRowContext(ctx, writersStat, site)
	var writer_count int64
	err := row.Scan(&writer_count)
	return writer_count, err
}
